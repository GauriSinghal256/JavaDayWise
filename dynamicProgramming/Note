frogJump optimised summary 

In our optimized Frog Jump:

int prev1 = 0;  // cost to reach stone 0
int prev2 = 0;  // cost to reach stone (i - 2)


At the start:

We are on the 0th stone.

The cost to reach the 0th stone is 0 (we havenâ€™t jumped yet).

There is no stone -1 or -2, but we still need variables for later steps, so we initialize both prev1 and prev2 with 0.

ğŸ§© Step-by-Step Reasoning
Case 1: First Jump (i = 1)

We only use prev1, not prev2:

int oneStep = prev1 + |cost[1] - cost[0]|;   // âœ… valid
int twoStep = Integer.MAX_VALUE;              // âŒ can't jump 2 steps yet


At this moment:

prev1 = dp[0] = 0

prev2 isnâ€™t used at all
â†’ So even if itâ€™s 0, it doesnâ€™t affect the result.

Case 2: Second Jump (i = 2)

Now weâ€™ll use both:

int oneStep = prev1 + |cost[2] - cost[1]|;
int twoStep = prev2 + |cost[2] - cost[0]|;


Hereâ€™s what each means:

prev1 â†’ cost to reach stone 1

prev2 â†’ cost to reach stone 0

Since dp[0] = 0, we initialize prev2 = 0 so that when we compute for i = 2, it matches the real dp value for stone 0.